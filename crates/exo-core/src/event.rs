use crate::crypto::{hash_bytes, Blake3Hash};
use crate::hlc::HybridLogicalClock;
use ed25519_dalek::Signature;
use serde::{Deserialize, Serialize};

/// Determine DID type later (string for now to avoid circular dep with exo-identity).
pub type Did = String;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EventEnvelope {
    /// Parent event_ids establishing DAG causality.
    pub parents: Vec<Blake3Hash>,

    /// Hybrid Logical Clock for causality ordering.
    pub logical_time: HybridLogicalClock,

    /// DID of the event author.
    pub author: Did,

    /// Key version used for signing.
    pub key_version: u64,

    /// Polymorphic payload.
    pub payload: EventPayload,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum EventPayload {
    Genesis {
        network_id: String,
    },
    IdentityCreated {
        // Stubs for now, will refine
        did_doc_cid: String,
    },
    // Add other variants as implemented
    Opaque(Vec<u8>),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LedgerEvent {
    pub envelope: EventEnvelope,
    pub event_id: Blake3Hash,
    pub signature: Signature,
}

/// Compute canonical event ID.
pub fn compute_event_id(envelope: &EventEnvelope) -> Result<Blake3Hash, serde_cbor::Error> {
    // Canonical CBOR encoding
    let canonical_bytes = serde_cbor::to_vec(envelope)?;
    Ok(hash_bytes(&canonical_bytes))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::compute_signature;
    use ed25519_dalek::SigningKey;
    use rand::rngs::OsRng;

    #[test]
    fn test_event_creation() {
        let envelope = EventEnvelope {
            parents: vec![],
            logical_time: HybridLogicalClock {
                physical_ms: 1000,
                logical: 0,
            },
            author: "did:exo:test".to_string(),
            key_version: 1,
            payload: EventPayload::Opaque(vec![1, 2, 3]),
        };

        let event_id = compute_event_id(&envelope).unwrap();

        let mut csprng = OsRng;
        let signing_key = SigningKey::generate(&mut csprng);
        let sig = compute_signature(&signing_key, &event_id);

        let event = LedgerEvent {
            envelope,
            event_id,
            signature: sig,
        };

        // Assert event_id is not empty
        assert_ne!(event.event_id.0, [0u8; 32]);
    }
}
